#pragma once

#include "hashing.h"
#include "mathtypes.h"

#include <array>

// TODO: This can be larger, because although faces can only
// use plane 0-32767, clipnodes can use plane 0-65535.
constexpr std::ptrdiff_t MAX_MAP_PLANES = 32768;

// (from email): I have been building a rather complicated map, and
// using your latest tools (1.61) it seemed to compile fine.  However,
// in game, the engine was dropping a lot of faces from almost every
// FUNC_WALL, and also caused a strange texture phenomenon in software
// mode (see attached screen shot).  When I compiled with v1.41, I
// noticed that it hit the MAX_MAP_PLANES limit of 32k.  After deleting
// some brushes I was able to bring the map under the limit, and all of
// the previous errors went away.
constexpr std::ptrdiff_t MAX_INTERNAL_MAP_PLANES = 256 * 1024;

constexpr float PLANE_NORMAL_EPSILON = 0.00001f;
// constexpr float DIR_EPSILON = 0.0001f;
constexpr float DIR_EPSILON = 1 / 8192.0f;
constexpr float PLANE_DIST_EPSILON = 0.04f;

constexpr float DIST_EPSILON = 0.04f;

enum class planetype {
	plane_x = 0,
	plane_y,
	plane_z,
	plane_anyx,
	plane_anyy,
	plane_anyz
};
constexpr planetype first_axial{ planetype::plane_x };
constexpr planetype last_axial{ planetype::plane_z };

constexpr auto round_to_dir_epsilon(std::floating_point auto f) {
	return std::round(f * (1 / DIR_EPSILON)) * DIR_EPSILON;
}

template <std::floating_point T>
constexpr planetype plane_type_for_normal(std::array<T, 3> const & normal
) noexcept {
	T const ax = std::abs(normal[0]);
	T const ay = std::abs(normal[1]);
	T const az = std::abs(normal[2]);
	if (ax > 1.0 - DIR_EPSILON && ay < DIR_EPSILON && az < DIR_EPSILON) {
		return planetype::plane_x;
	}

	if (ay > 1.0 - DIR_EPSILON && az < DIR_EPSILON && ax < DIR_EPSILON) {
		return planetype::plane_y;
	}

	if (az > 1.0 - DIR_EPSILON && ax < DIR_EPSILON && ay < DIR_EPSILON) {
		return planetype::plane_z;
	}

	if ((ax >= ay) && (ax >= az)) {
		return planetype::plane_anyx;
	}
	if ((ay >= ax) && (ay >= az)) {
		return planetype::plane_anyy;
	}
	return planetype::plane_anyz;
}

// The final plane type that ends up in the BSP
struct dplane_t final {
	std::array<float, 3> normal;
	float dist; // Distance from the origin
	planetype type;
};

// mapplane_t is generated by HLCSG and used by HLBSP. It is not the
// final plane type that ends up in the BSP - that's dplane_t
struct mapplane_t final {
	double3_array normal;
	double3_array origin;
	double dist; // Distance from the origin
	planetype type;
};

namespace std {
	template <>
	struct hash<mapplane_t> {
		constexpr std::size_t operator()(mapplane_t const & mapPlane
		) const noexcept {
			return hash_multiple(
				mapPlane.normal,
				mapPlane.origin,
				mapPlane.dist,
				mapPlane.type
			);
		}
	};
} // namespace std
