#include "qrad.h"
#include "wad_structs.h"
#include "worldspawn_wad_value_parser.h"

#include <cstring>

int g_numtextures;
std::unique_ptr<radtexture_t[]> g_textures;

std::vector<std::filesystem::path> g_wadDirs;

void AddWadFolder(std::filesystem::path path) {
	g_wadDirs.emplace_back(std::move(path));
}

struct wadfile_t {
	wad_lumpinfo* lumpinfos;
	FILE* file;
	std::filesystem::path path;
	int filesize;
	int numlumps;
};

std::vector<wadfile_t> g_wadFiles;

bool g_wadfiles_opened;

constexpr int ordering_as_int(std::strong_ordering cmp) noexcept {
	return (cmp < 0) ? -1 : ((cmp == 0) ? 0 : 1);
}

static int lump_sorter_by_name(void const * lump1, void const * lump2) {
	wad_lumpinfo* plump1 = (wad_lumpinfo*) lump1;
	wad_lumpinfo* plump2 = (wad_lumpinfo*) lump2;
	return ordering_as_int(plump1->name <=> plump2->name);
}

void OpenWadFile(std::filesystem::path name, bool fullpath = false) {
	wadfile_t wad{};
	if (fullpath) {
		wad.path = std::move(name);
		wad.file = fopen(wad.path.c_str(), "rb");
		if (!wad.file) {
			Error("Couldn't open %s", wad.path.c_str());
		}
	} else {
		for (std::filesystem::path const & dirPath : g_wadDirs) {
			wad.path = dirPath / name;
			wad.file = fopen(wad.path.c_str(), "rb");
			if (wad.file) {
				break;
			}
		}
		if (!wad.file) {
			Fatal(
				assume_COULD_NOT_LOCATE_WAD, "Could not locate wad file %s",
				name.c_str()
			);
			return;
		}
	}
	Log("Using Wadfile: %s\n", wad.path.c_str());
	wad.filesize = q_filelength(wad.file);
	wadinfo_t wadinfo;
	if (wad.filesize < (int) sizeof(wadinfo)) {
		Error("Invalid wad file '%s'.", wad.path.c_str());
	}
	SafeRead(wad.file, &wadinfo, sizeof(wadinfo));
	wadinfo.numlumps = (wadinfo.numlumps);
	wadinfo.infotableofs = (wadinfo.infotableofs);
	if (!has_wad_identification(wadinfo)) {
		Error("%s isn't a Wadfile!", wad.path.c_str());
	}
	wad.numlumps = wadinfo.numlumps;
	if (wad.numlumps < 0 || wadinfo.infotableofs < 0
		|| wadinfo.infotableofs + wad.numlumps * (int) sizeof(wad_lumpinfo)
			> wad.filesize) {
		Error("Invalid wad file '%s'.", wad.path.c_str());
	}
	wad.lumpinfos
		= (wad_lumpinfo*) malloc(wad.numlumps * sizeof(wad_lumpinfo));
	hlassume(wad.lumpinfos != nullptr, assume_NoMemory);
	if (fseek(wad.file, wadinfo.infotableofs, SEEK_SET)) {
		Error("File read failure: %s", wad.path.c_str());
	}
	for (std::size_t i = 0; i < wad.numlumps; ++i) {
		SafeRead(wad.file, &wad.lumpinfos[i], sizeof(wad_lumpinfo));
		if (!wad.lumpinfos[i].name.validate_and_normalize()) {
			Error(
				"Texture number %zu has a bad name. The WAD file %s has been corrupted or it was generated by a program that either incorrectly tries to write texture names longer than 15 code units or writes non-UTF-8 names.",
				i, wad.path.c_str()
			);
		}
		wad.lumpinfos[i].filepos = (wad.lumpinfos[i].filepos);
		wad.lumpinfos[i].disksize = (wad.lumpinfos[i].disksize);
		wad.lumpinfos[i].size = (wad.lumpinfos[i].size);
	}
	qsort(
		wad.lumpinfos, wad.numlumps, sizeof(wad_lumpinfo),
		lump_sorter_by_name
	);

	g_wadFiles.push_back(std::move(wad));
}

void TryOpenWadFiles() {
	if (g_wadfiles_opened) {
		return;
	}
	g_wadfiles_opened = true;

	char filename[_MAX_PATH];
	safe_snprintf(filename, _MAX_PATH, "%s.wa_", g_Mapname);
	if (std::filesystem::exists(filename)) {
		OpenWadFile(filename, true);
	} else {
		Warning("Couldn't open %s", filename);
		Log("Opening wad files from directories:\n");
		if (g_wadDirs.empty()) {
			Warning("No wad directories have been set.");
		} else {
			for (std::filesystem::path const & dirPath : g_wadDirs) {
				Log("  %s\n", dirPath.c_str());
			}
		}
		std::u8string_view wadValue
			= value_for_key(&g_entities[0], u8"wad");
		for (std::u8string_view wadFilename :
			 worldspawn_wad_value_parser(wadValue)) {
			OpenWadFile((char const *) std::u8string(wadFilename).c_str());
		}
		while (!wadValue.empty()) {
			char8_t const * nextSeparator
				= std::ranges::find(wadValue, u8';');
			std::u8string_view pathString{ wadValue.data(), nextSeparator };

			if (!pathString.empty()) {
				OpenWadFile(
					filename_in_file_path_string_as_path(pathString).c_str()
				);
			}

			if (pathString.length() == wadValue.length()) {
				wadValue = {};
			} else {
				wadValue = wadValue.substr(pathString.length() + 1);
			}
		}
	}
	CheckFatal();
}

void TryCloseWadFiles() {
	if (!g_wadfiles_opened) {
		return;
	}
	g_wadfiles_opened = false;
	for (wadfile_t& wadfile : g_wadFiles) {
		free(wadfile.lumpinfos);
		fclose(wadfile.file);
	}
	g_wadFiles.clear();
}

static void DefaultTexture(radtexture_t* tex, wad_texture_name name) {
	int i;
	tex->width = 16;
	tex->height = 16;
	tex->name = name;
	tex->canvas
		= std::make_unique<std::uint8_t[]>(tex->width * tex->height);
	for (i = 0; i < 256; i++) {
		tex->palette[i].fill(0x80);
	}
}

void LoadTexture(radtexture_t* tex, miptex_t const * mt, int size) {
	miptex_t const * header = mt;
	std::uint8_t const * data = (std::uint8_t const *) mt;
	tex->width = header->width;
	tex->height = header->height;
	tex->name = header->name;
	if (tex->width <= 0 || tex->height <= 0
		|| tex->width % (2 * 1 << (MIPLEVELS - 1)) != 0
		|| tex->height % (2 * (1 << (MIPLEVELS - 1))) != 0) {
		Error(
			"Texture '%s': dimension (%dx%d) is not multiple of %d.",
			tex->name.c_str(), tex->width, tex->height,
			2 * (1 << (MIPLEVELS - 1))
		);
	}
	int mipsize, i;
	for (mipsize = 0, i = 0; i < MIPLEVELS; i++) {
		if ((int) mt->offsets[i] != (int) sizeof(miptex_t) + mipsize) {
			Error(
				"Texture '%s': unexpected miptex offset.", tex->name.c_str()
			);
		}
		mipsize += (tex->width >> i) * (tex->height >> i);
	}
	if (size < (int) sizeof(miptex_t) + mipsize + 2 + 256 * 3) {
		Error("Texture '%s': no enough data.", tex->name.c_str());
	}
	if (*(unsigned short*) &data[sizeof(miptex_t) + mipsize] != 256) {
		Error("Texture '%s': palette size is not 256.", tex->name.c_str());
	}
	tex->canvas = std::make_unique_for_overwrite<std::uint8_t[]>(
		tex->width * tex->height
	);
	for (int i = 0; i < tex->height; i++) {
		for (int j = 0; j < tex->width; j++) {
			tex->canvas[i * tex->width + j]
				= data[sizeof(miptex_t) + i * tex->width + j];
		}
	}
	for (int i = 0; i < 256; i++) {
		for (int j = 0; j < 3; j++) {
			tex->palette[i][j]
				= data[sizeof(miptex_t) + mipsize + 2 + i * 3 + j];
		}
	}
}

void LoadTextureFromWad(radtexture_t* tex, miptex_t const * header) {
	bool loadedTexture = false;
	tex->width = header->width;
	tex->height = header->height;
	tex->name = header->name;
	for (wadfile_t& wad : g_wadFiles) {
		wad_lumpinfo temp;
		temp.name = tex->name;
		wad_lumpinfo* found = (wad_lumpinfo*) bsearch(
			&temp, wad.lumpinfos, wad.numlumps, sizeof(wad_lumpinfo),
			lump_sorter_by_name
		);
		if (found) {
			Developer(
				developer_level::message, "Texture '%s': found in '%s'.\n",
				tex->name.c_str(), wad.path.c_str()
			);
			if (found->type != 67 || found->compression != 0) {
				continue;
			}
			if (found->disksize < (int) sizeof(miptex_t)
				|| found->filepos < 0
				|| found->filepos + found->disksize > wad.filesize) {
				Warning(
					"Texture '%s': invalid texture data in '%s'.",
					tex->name.c_str(), wad.path.c_str()
				);
				continue;
			}
			miptex_t* mt = (miptex_t*) malloc(found->disksize);
			hlassume(mt != nullptr, assume_NoMemory);
			if (fseek(wad.file, found->filepos, SEEK_SET)) {
				Error("File read failure");
			}
			SafeRead(wad.file, mt, found->disksize);
			if (!mt->name.validate_and_normalize()) {
				Warning(
					"Texture '%s': invalid texture data in '%s'.",
					tex->name.c_str(), wad.path.c_str()
				);
				free(mt);
				continue;
			}
			Developer(
				developer_level::message,
				"Texture '%s': name '%s', width %d, height %d.\n",
				tex->name.c_str(), mt->name.c_str(), mt->width, mt->height
			);
			if (!strings_equal_with_ascii_case_insensitivity(
					mt->name, tex->name
				)) {
				Warning(
					"Texture '%s': texture name '%s' differs from its reference name '%s' in '%s'.",
					tex->name.c_str(), mt->name.c_str(), tex->name.c_str(),
					wad.path.c_str()
				);
			}
			LoadTexture(tex, mt, found->disksize);
			free(mt);
			loadedTexture = true;
			break;
		}
	}
	if (!loadedTexture) {
		Warning(
			"Texture '%s': texture is not found in wad files.",
			tex->name.c_str()
		);
		DefaultTexture(tex, tex->name);
		return;
	}
}

void LoadTextures() {
	if (!g_notextures) {
		Log("Load Textures:\n");
	}
	g_numtextures = g_texdatasize
		? ((dmiptexlump_t*) g_dtexdata.data())->nummiptex
		: 0;
	g_textures = std::make_unique<radtexture_t[]>(g_numtextures);
	hlassume(g_textures != nullptr, assume_NoMemory);
	int i;
	for (i = 0; i < g_numtextures; i++) {
		int offset = ((dmiptexlump_t*) g_dtexdata.data())->dataofs[i];
		int size = g_texdatasize - offset;
		radtexture_t* tex = &g_textures[i];
		if (g_notextures) {
			DefaultTexture(tex, wad_texture_name{ u8"default" });
		} else if (offset < 0 || size < (int) sizeof(miptex_t)) {
			Warning("Invalid texture data in '%s'.", g_source);
			DefaultTexture(tex, wad_texture_name{ u8"" });
		} else {
			miptex_t* mt = (miptex_t*) &g_dtexdata[offset];
			if (mt->offsets[0]) {
				Developer(
					developer_level::message,
					"Texture '%s': found in '%s'.\n", mt->name.c_str(),
					g_source
				);
				Developer(
					developer_level::message,
					"Texture '%s': width %d, height %d.\n",
					mt->name.c_str(), mt->width, mt->height
				);
				LoadTexture(tex, mt, size);
			} else {
				TryOpenWadFiles();
				LoadTextureFromWad(tex, mt);
			}
		}
		{
			float3_array total;
			VectorClear(total);
			for (int j = 0; j < tex->width * tex->height; j++) {
				float3_array reflectivity;
				if (tex->name.is_transparent_or_decal()
					&& tex->canvas[j] == 0xFF) {
					VectorFill(reflectivity, 0.0);
				} else {
					auto const & rgb
						= tex->palette[(std::size_t) tex->canvas[j]];
					reflectivity = { rgb[0] * float(1.0 / 255.0),
									 rgb[1] * float(1.0 / 255.0),
									 rgb[2] * float(1.0 / 255.0) };
					for (int k = 0; k < 3; k++) {
						reflectivity[k]
							= pow(reflectivity[k], g_texreflectgamma);
					}
					VectorScale(
						reflectivity, g_texreflectscale, reflectivity
					);
				}
				VectorAdd(total, reflectivity, total);
			}
			VectorScale(
				total, 1.0 / (double) (tex->width * tex->height), total
			);
			VectorCopy(total, tex->reflectivity);
			Developer(
				developer_level::message,
				"Texture '%s': reflectivity is (%f,%f,%f).\n",
				tex->name.c_str(), tex->reflectivity[0],
				tex->reflectivity[1], tex->reflectivity[2]
			);
			if (VectorMaximum(tex->reflectivity) > 1.0 + NORMAL_EPSILON) {
				Warning(
					"Texture '%s': reflectivity (%f,%f,%f) greater than 1.0.",
					tex->name.c_str(), tex->reflectivity[0],
					tex->reflectivity[1], tex->reflectivity[2]
				);
			}
		}
	}
	if (!g_notextures) {
		Log("%i textures referenced\n", g_numtextures);
		TryCloseWadFiles();
	}
}

// color quantization algorithm

constexpr std::size_t CQ_DIMENSIONS = 3;

template <class T, class T2, class T3>
inline void CQ_VectorSubtract(
	T const a[CQ_DIMENSIONS], const T2 b[CQ_DIMENSIONS], T3 c[CQ_DIMENSIONS]
) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] - b[x];
	}
}

template <class T, class T2, class T3>
inline void CQ_VectorAdd(
	T const a[CQ_DIMENSIONS], const T2 b[CQ_DIMENSIONS], T3 c[CQ_DIMENSIONS]
) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] + b[x];
	}
}

template <class T, class T2>
inline void
CQ_VectorScale(T const a[CQ_DIMENSIONS], const T2 b, T c[CQ_DIMENSIONS]) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		c[x] = a[x] * b;
	}
}

template <class T, class T2>
inline void CQ_VectorCopy(T const a[CQ_DIMENSIONS], T2 b[CQ_DIMENSIONS]) {
	for (int x = 0; x < CQ_DIMENSIONS; x++) {
		b[x] = a[x];
	}
}

template <class T>
inline void CQ_VectorClear(T a[CQ_DIMENSIONS]) {
	for (std::size_t x = 0; x < CQ_DIMENSIONS; ++x) {
		a[x] = (T) 0;
	}
}

template <class T>
inline T CQ_DotProduct(T const a[CQ_DIMENSIONS], T const b[CQ_DIMENSIONS]) {
	T dot = (T) 0;
	for (std::size_t x = 0; x < CQ_DIMENSIONS; ++x) {
		dot += a[x] * b[x];
	}
	return dot;
}

typedef struct {
	int axis;
	int dist;
	double numpoints[2];
} cq_splitter_t; // partition the space into { point: point[axis] < dist }
				 // and { point: point[axis] >= dist }

typedef struct cq_node_s {
	bool isleafnode;
	cq_node_s* parentnode;
	cq_node_s* childrennode[2];

	int numpoints; // numpoints > 0
	unsigned char (*refpoints)[CQ_DIMENSIONS];
	double centerofpoints[CQ_DIMENSIONS];

	bool needsplit;
	cq_splitter_t bestsplitter;
	double splitpriority;
} cq_node_t; // a cuboid region; the root node is the entire cube whose size
			 // is 255

typedef struct cq_searchnode_s {
	bool isleafnode;
	cq_searchnode_s* childrennode[2];

	int planeaxis;
	int planedist;

	int result;
} cq_searchnode_t;

static void CQ_SelectPartition(cq_node_t* node) {
	CQ_VectorClear(node->centerofpoints);
	for (int i = 0; i < node->numpoints; i++) {
		CQ_VectorAdd(
			node->centerofpoints, node->refpoints[i], node->centerofpoints
		);
	}
	CQ_VectorScale(
		node->centerofpoints, 1 / (double) node->numpoints,
		node->centerofpoints
	);

	node->needsplit = false;
	for (int k = 0; k < CQ_DIMENSIONS; k++) {
		double count;
		double counts[256];
		double sum[CQ_DIMENSIONS];
		double sums[256][CQ_DIMENSIONS];

		double bucketsums[256][CQ_DIMENSIONS];
		int bucketsizes[256];

		unsigned char const(*nodepoints)[CQ_DIMENSIONS] = node->refpoints;
		int const nodenumpoints = node->numpoints;

		memset(bucketsums, 0, 256 * sizeof(double[CQ_DIMENSIONS]));
		memset(bucketsizes, 0, 256 * sizeof(int));
		for (int i = 0; i < nodenumpoints; i++) {
			int j = nodepoints[i][k];
			bucketsizes[j]++;
			CQ_VectorAdd(bucketsums[j], nodepoints[i], bucketsums[j]);
		}

		int min = 256;
		int max = -1;
		count = 0;
		CQ_VectorClear(sum);
		for (int j = 0; j < 256; j++) {
			counts[j] = count;
			CQ_VectorCopy(sum, sums[j]);
			count += bucketsizes[j];
			CQ_VectorAdd(sum, bucketsums[j], sum);
			if (bucketsizes[j] > 0) {
				if (j < min) {
					min = j;
				}
				if (j > max) {
					max = j;
				}
			}
		}
		if (max < min) {
			Error("CQ_SelectPartition: internal error");
		}
		// sweep along the axis and find the plane that maximize square
		// error reduction
		for (int j = min + 1; j < max + 1; j++) {
			double priority = 0; // the decrease in total square deviation
			priority -= CQ_DotProduct(sum, sum) / count;
			priority += CQ_DotProduct(sums[j], sums[j]) / counts[j];
			double remain[CQ_DIMENSIONS];
			CQ_VectorSubtract(
				sum, sums[j], remain
			); // sums and counts are precise (have no round-off error)
			priority += CQ_DotProduct(remain, remain) / (count - counts[j]);
			if (node->needsplit == false
				|| priority > node->splitpriority + 0.1
				|| priority >= node->splitpriority - 0.1
					&& fabs(counts[j] - count / 2) < fabs(
						   node->bestsplitter.numpoints[0] - count / 2
					   )) {
				node->needsplit = true;
				node->splitpriority = priority;
				node->bestsplitter.axis = k;
				node->bestsplitter.dist = j;
				node->bestsplitter.numpoints[0] = counts[j];
				node->bestsplitter.numpoints[1] = count - counts[j];
			}
		}
	}
}

static cq_searchnode_t* CQ_AllocSearchTree(int maxcolors) {
	cq_searchnode_t* searchtree;
	searchtree = (cq_searchnode_t*) malloc(
		(2 * maxcolors - 1) * sizeof(cq_searchnode_t)
	);
	hlassume(searchtree != nullptr, assume_NoMemory);
	return searchtree;
}

static void CQ_FreeSearchTree(cq_searchnode_t* searchtree) {
	free(searchtree);
}

static void CQ_CreatePalette(
	int numpoints,
	unsigned char const (*points)[CQ_DIMENSIONS],
	int maxcolors,
	unsigned char (*colors_out)[CQ_DIMENSIONS],
	int& numcolors_out,
	cq_searchnode_t* searchtree_out
) //[2 * maxcolors - 1]
{
	if (numpoints <= 0 || maxcolors <= 0) {
		numcolors_out = 0;
		return;
	}

	unsigned char(*pointarray)[CQ_DIMENSIONS];
	pointarray = (unsigned char(*)[CQ_DIMENSIONS]
	) malloc(numpoints * sizeof(unsigned char[CQ_DIMENSIONS]));
	hlassume(pointarray != nullptr, assume_NoMemory);
	memcpy(
		pointarray, points, numpoints * sizeof(unsigned char[CQ_DIMENSIONS])
	);

	cq_node_t* n;
	cq_searchnode_t* s;
	int numnodes = 0;
	int maxnodes = 2 * maxcolors - 1;
	cq_node_t* nodes = (cq_node_t*) malloc(maxnodes * sizeof(cq_node_t));
	hlassume(nodes != nullptr, assume_NoMemory);

	n = &nodes[0];
	numnodes++;

	n->isleafnode = true;
	n->parentnode = nullptr;
	n->numpoints = numpoints;
	n->refpoints = pointarray;
	CQ_SelectPartition(n);

	for (int i = 1; i < maxcolors; i++) {
		bool needsplit;
		double bestpriority;
		cq_node_t* bestnode;

		needsplit = false;
		for (int j = 0; j < numnodes; j++) {
			n = &nodes[j];
			if (!n->isleafnode || !n->needsplit) {
				continue;
			}
			if (needsplit == false
				|| n->splitpriority > bestpriority + 0.1) {
				needsplit = true;
				bestpriority = n->splitpriority;
				bestnode = n;
			}
		}
		if (!needsplit) {
			break;
		}

		bestnode->isleafnode = false;
		for (int k = 0; k < 2; k++) {
			n = &nodes[numnodes];
			numnodes++;
			if (numnodes > maxnodes) {
				Error("CQ_CreatePalette: internal error");
			}

			bestnode->childrennode[k] = n;
			n->isleafnode = true;
			n->parentnode = bestnode;
			n->numpoints = 0;
			n->refpoints = nullptr;
		}

		// partition the points using the best splitter
		{
			int const splitaxis = bestnode->bestsplitter.axis;
			int const splitdist = bestnode->bestsplitter.dist;
			int const numpoints = bestnode->numpoints;
			unsigned char(*points)[CQ_DIMENSIONS] = bestnode->refpoints;

			unsigned char(*left)[CQ_DIMENSIONS];
			unsigned char(*right)[CQ_DIMENSIONS];
			left = &bestnode->refpoints[0];
			right = &bestnode->refpoints[bestnode->numpoints - 1];
			while (1) {
				while ((*left)[splitaxis] < splitdist) {
					left++;
				}
				while ((*right)[splitaxis] >= splitdist) {
					right--;
				}
				if (left >= right) {
					break;
				}
				unsigned char tmp[CQ_DIMENSIONS];
				CQ_VectorCopy(*left, tmp);
				CQ_VectorCopy(*right, *left);
				CQ_VectorCopy(tmp, *right);
			}
			if (right != left - 1) {
				Error("CQ_CreatePalette: internal error");
			}

			bestnode->childrennode[0]->numpoints
				= left - bestnode->refpoints;
			bestnode->childrennode[0]->refpoints = bestnode->refpoints;
			bestnode->childrennode[1]->numpoints
				= &bestnode->refpoints[bestnode->numpoints] - left;
			bestnode->childrennode[1]->refpoints = left;
			if (bestnode->childrennode[0]->numpoints <= 0
				|| bestnode->childrennode[0]->numpoints
					!= bestnode->bestsplitter.numpoints[0]) {
				Error("CQ_CreatePalette: internal error");
			}
			if (bestnode->childrennode[1]->numpoints <= 0
				|| bestnode->childrennode[1]->numpoints
					!= bestnode->bestsplitter.numpoints[1]) {
				Error("CQ_CreatePalette: internal error");
			}
		}

		CQ_SelectPartition(bestnode->childrennode[0]);
		CQ_SelectPartition(bestnode->childrennode[1]);
	}

	for (int i = 0; i < numnodes; i++) {
		n = &nodes[i];
		s = &searchtree_out[i];
		s->isleafnode = n->isleafnode;
		if (!n->isleafnode) {
			s->planeaxis = n->bestsplitter.axis;
			s->planedist = n->bestsplitter.dist;
			s->childrennode[0]
				= &searchtree_out[n->childrennode[0] - nodes];
			s->childrennode[1]
				= &searchtree_out[n->childrennode[1] - nodes];
		}
	}

	numcolors_out = 0;
	n = &nodes[0];
	while (1) {
		while (!n->isleafnode) {
			n = n->childrennode[0];
		}
		s = &searchtree_out[n - nodes];
		s->result = numcolors_out;
		for (int k = 0; k < CQ_DIMENSIONS; k++) {
			int val = (int) floor(n->centerofpoints[k] + 0.5 + 0.00001);
			val = std::max(0, std::min(val, 255));
			colors_out[numcolors_out][k] = val;
		}
		numcolors_out++;
		while (n->parentnode) {
			if (n == n->parentnode->childrennode[0]) {
				break;
			}
			n = n->parentnode;
		}
		if (!n->parentnode) {
			break;
		}
		n = n->parentnode->childrennode[1];
	}

	if (2 * numcolors_out - 1 != numnodes) {
		Error("CQ_CreatePalette: internal error");
	}

	free(pointarray);
	free(nodes);
}

static void CQ_MapPoint_r(
	int* bestdist,
	int* best,
	cq_searchnode_t* node,
	unsigned char const (*colors)[CQ_DIMENSIONS],
	unsigned char const point[CQ_DIMENSIONS],
	int searchradius
) {
	while (!node->isleafnode) {
		int dist = point[node->planeaxis] - node->planedist;
		if (dist <= -searchradius) {
			node = node->childrennode[0];
		} else if (dist >= searchradius - 1) {
			node = node->childrennode[1];
		} else {
			CQ_MapPoint_r(
				bestdist, best, node->childrennode[0], colors, point,
				searchradius
			);
			CQ_MapPoint_r(
				bestdist, best, node->childrennode[1], colors, point,
				searchradius
			);
			return;
		}
	}
	int dist = 0;
	for (int k = 0; k < CQ_DIMENSIONS; k++) {
		dist += (colors[node->result][k] - point[k])
			* (colors[node->result][k] - point[k]);
	}
	if (dist <= *bestdist) {
		if (dist < *bestdist || node->result < *best) {
			*bestdist = dist;
			*best = node->result;
		}
	}
}

static int CQ_MapPoint(
	unsigned char const point[CQ_DIMENSIONS],
	unsigned char const (*colors)[CQ_DIMENSIONS],
	int numcolors,
	cq_searchnode_t* searchtree
) {
	if (numcolors <= 0) {
		Error("CQ_MapPoint: internal error");
	}

	cq_searchnode_t* node;
	int bestdist;
	int best;
	int searchradius;

	for (node = searchtree; !node->isleafnode;) {
		node
			= node->childrennode[point[node->planeaxis] >= node->planedist];
	}
	best = node->result;
	bestdist = 0;
	for (int k = 0; k < CQ_DIMENSIONS; k++) {
		bestdist
			+= (colors[best][k] - point[k]) * (colors[best][k] - point[k]);
	}

	searchradius = (int) ceil(sqrt((double) bestdist) + 0.1);
	CQ_MapPoint_r(
		&bestdist, &best, searchtree, colors, point, searchradius
	);
	return best;
}

// =====================================================================================
//  EmbedLightmapInTextures
//      check for "zhlt_embedlightmap" and update g_dfaces, g_texinfo,
//      g_dtexdata and g_dlightdata
// =====================================================================================

#define RADTEXTURES_MAX \
	2048 // should be smaller than 62 * 62 and smaller than MAX_MAP_TEXTURES
static int g_newtextures_num = 0;
static byte* g_newtextures_data[RADTEXTURES_MAX];
static int g_newtextures_size[RADTEXTURES_MAX];

int NewTextures_GetCurrentMiptexIndex() {
	dmiptexlump_t* texdata = (dmiptexlump_t*) g_dtexdata.data();
	return texdata->nummiptex + g_newtextures_num;
}

void NewTextures_PushTexture(int size, void* data) {
	if (g_newtextures_num >= RADTEXTURES_MAX) {
		Error(
			"the number of textures created by hlrad has exceeded its internal limit(%d).",
			(int) RADTEXTURES_MAX
		);
	}
	g_newtextures_data[g_newtextures_num] = (byte*) malloc(size);
	hlassume(
		g_newtextures_data[g_newtextures_num] != nullptr, assume_NoMemory
	);
	memcpy(g_newtextures_data[g_newtextures_num], data, size);
	g_newtextures_size[g_newtextures_num] = size;
	g_newtextures_num++;
}

void NewTextures_Write() {
	if (!g_newtextures_num) {
		return;
	}

	int i;
	dmiptexlump_t* texdata = (dmiptexlump_t*) g_dtexdata.data();

	std::byte* dataaddr
		= (std::byte*) &texdata->dataofs[texdata->nummiptex];
	int datasize = (g_dtexdata.data() + g_texdatasize) - dataaddr;
	std::byte* newdataaddr
		= (std::byte*) &texdata
			  ->dataofs[texdata->nummiptex + g_newtextures_num];
	hlassume(
		g_texdatasize + (newdataaddr - dataaddr) <= g_max_map_miptex,
		assume_MAX_MAP_MIPTEX
	);
	memmove(newdataaddr, dataaddr, datasize);
	g_texdatasize += newdataaddr - dataaddr;
	for (i = 0; i < texdata->nummiptex; i++) {
		if (texdata->dataofs[i] < 0) // bad texture
		{
			continue;
		}
		texdata->dataofs[i] += newdataaddr - dataaddr;
	}

	hlassume(
		texdata->nummiptex + g_newtextures_num < MAX_MAP_TEXTURES,
		assume_MAX_MAP_TEXTURES
	);
	for (i = 0; i < g_newtextures_num; i++) {
		hlassume(
			g_texdatasize + g_newtextures_size[i] <= g_max_map_miptex,
			assume_MAX_MAP_MIPTEX
		);
		memcpy(
			g_dtexdata.data() + g_texdatasize, g_newtextures_data[i],
			g_newtextures_size[i]
		);
		texdata->dataofs[texdata->nummiptex + i] = g_texdatasize;
		g_texdatasize += g_newtextures_size[i];
	}
	texdata->nummiptex += g_newtextures_num;

	for (int i = 0; i < g_newtextures_num; i++) {
		free(g_newtextures_data[i]);
	}
	g_newtextures_num = 0;
}

static unsigned int Hash(int size, void* data) {
	unsigned int hash = 0;
	for (int i = 0; i < size; i++) {
		hash = 31 * hash + ((unsigned char*) data)[i];
	}
	return hash;
}

static void GetLightInt(
	dface_t* face, int const texsize[2], int ix, int iy, float3_array& light
) {
	ix = std::max(0, std::min(ix, texsize[0]));
	iy = std::max(0, std::min(iy, texsize[1]));
	VectorClear(light);
	if (face->lightofs < 0) {
		return;
	}
	for (int k = 0; k < MAXLIGHTMAPS && face->styles[k] != 255; k++) {
		std::byte const * samples
			= &g_dlightdata
				  [face->lightofs
				   + k * (texsize[0] + 1) * (texsize[1] + 1) * 3];
		if (face->styles[k] == 0) {
			VectorAdd(
				light,
				(std::uint8_t const *) &samples
					[(iy * (texsize[0] + 1) + ix) * 3],
				light
			);
		}
	}
}

static void GetLight(
	dface_t* face,
	int const texsize[2],
	double x,
	double y,
	float3_array& light
) {
	int ix, iy;
	double dx, dy;
	ix = (int) floor(x);
	iy = (int) floor(y);
	dx = x - ix;
	dx = std::max(0.0, std::min(dx, 1.0));
	dy = y - iy;
	dy = std::max(0.0, std::min(dy, 1.0));

	// do bilinear interpolation
	float3_array light00, light10, light01, light11;
	GetLightInt(face, texsize, ix, iy, light00);
	GetLightInt(face, texsize, ix + 1, iy, light10);
	GetLightInt(face, texsize, ix, iy + 1, light01);
	GetLightInt(face, texsize, ix + 1, iy + 1, light11);
	float3_array light0, light1;
	VectorScale(light00, 1 - dy, light0);
	VectorMA(light0, dy, light01, light0);
	VectorScale(light10, 1 - dy, light1);
	VectorMA(light1, dy, light11, light1);
	VectorScale(light0, 1 - dx, light);
	VectorMA(light, dx, light1, light);
}

static std::optional<wad_texture_name>
GetValidTextureName(std::uint32_t miptex) {
	int const numtextures = g_texdatasize
		? ((dmiptexlump_t*) g_dtexdata.data())->nummiptex
		: 0;

	if (miptex >= numtextures) {
		return std::nullopt;
	}
	std::int32_t offset
		= ((dmiptexlump_t*) g_dtexdata.data())->dataofs[miptex];
	int size = g_texdatasize - offset;
	if (offset < 0
		|| g_dtexdata.data() + offset
			< (std::byte*) &((dmiptexlump_t*) g_dtexdata.data())
				  ->dataofs[numtextures]
		|| size < (int) sizeof(miptex_t)) {
		return std::nullopt;
	}

	wad_texture_name const textureName
		= ((miptex_t const &) g_dtexdata.data()[offset]).name;

	if (textureName.is_any_embedded_lightmap()) {
		return std::nullopt;
	}

	return textureName;
}

void EmbedLightmapInTextures() {
	if (g_dlightdata.empty()) {
		// hlrad hasn't run
		return;
	}
	if (!g_texdatasize) {
		// texdata hasn't been initialized
		return;
	}
	if (g_notextures) {
		// hlrad didn't load the wad files
		return;
	}

	int i, j, k;
	int miplevel;
	int count = 0;
	int count_bytes = 0;
	bool logged = false;

	for (i = 0; i < g_numfaces; i++) {
		dface_t* f = &g_dfaces[i];

		if (f->lightofs == -1) // some faces don't have lightmap
		{
			continue;
		}
		if (f->texinfo < 0 || f->texinfo >= g_numtexinfo) {
			continue;
		}

		entity_t* ent = g_face_entity[i];
		int originaltexinfonum = f->texinfo;
		texinfo_t* originaltexinfo = &g_texinfo[originaltexinfonum];

		auto maybeTexname = GetValidTextureName(originaltexinfo->miptex);

		if (!maybeTexname) {
			continue;
		}
		wad_texture_name const texname = maybeTexname.value();

		radtexture_t* tex = &g_textures[originaltexinfo->miptex];

		if (ent == &g_entities[0]) // world
		{
			continue;
		}
		if (texname.is_ordinary_sky()
			|| originaltexinfo->flags
				& TEX_SPECIAL) // skip special surfaces
		{
			continue;
		}
		if (!IntForKey(ent, u8"zhlt_embedlightmap")) {
			continue;
		}

		if (!logged) {
			Log("\n");
			Log("Embed Lightmap : ");
			Developer(developer_level::message, "\n");
			logged = true;
		}

		bool poweroftwo = DEFAULT_EMBEDLIGHTMAP_POWEROFTWO;
		float denominator = DEFAULT_EMBEDLIGHTMAP_DENOMINATOR;
		float gamma = DEFAULT_EMBEDLIGHTMAP_GAMMA;
		int resolution = DEFAULT_EMBEDLIGHTMAP_RESOLUTION;
		if (IntForKey(ent, u8"zhlt_embedlightmapresolution")) {
			resolution = IntForKey(ent, u8"zhlt_embedlightmapresolution");
			if (resolution <= 0 || resolution > TEXTURE_STEP
				|| ((resolution - 1) & resolution) != 0) {
				Error(
					"resolution cannot be %d; valid values are 1, 2, 4 ... %d.",
					resolution, (int) TEXTURE_STEP
				);
			}
		}

		// calculate texture size and allocate memory for all miplevels

		int texturesize[2];
		float(*texture)[5]; // red, green, blue and alpha channel; the last
							// one is number of samples
		byte(*texturemips[MIPLEVELS]
		)[4]; // red, green, blue and alpha channel
		int s, t;
		int texmins[2];
		int texmaxs[2];
		int texsize[2]; // texturesize = (texsize + 1) * TEXTURE_STEP
		int side[2];

		GetFaceExtents(i, texmins, texmaxs);
		texsize[0] = texmaxs[0] - texmins[0];
		texsize[1] = texmaxs[1] - texmins[1];
		if (texsize[0] < 0 || texsize[1] < 0
			|| texsize[0] > MAX_SURFACE_EXTENT
			|| texsize[1] > MAX_SURFACE_EXTENT) {
			Warning(
				"skipped a face with bad surface extents @ (%4.3f %4.3f %4.3f)",
				g_face_centroids[i][0], g_face_centroids[i][1],
				g_face_centroids[i][2]
			);
			continue;
		}

		for (k = 0; k < 2; k++) {
			texturesize[k] = (texsize[k] + 1) * TEXTURE_STEP;
			if (texturesize[k]
				< texsize[k] * TEXTURE_STEP + resolution * 4) {
				texturesize[k] = texsize[k] * TEXTURE_STEP
					+ resolution * 4; // prevent edge bleeding
			}
			texturesize[k] = (texturesize[k] + resolution - 1) / resolution;
			texturesize[k] += 15
				- (texturesize[k] + 15) % 16; // must be multiples of 16
			if (poweroftwo) {
				for (j = 0; j <= 30; j++) {
					if ((1 << j) >= texturesize[k]) {
						texturesize[k] = (1 << j);
						break;
					}
				}
			}
			side[k]
				= (texturesize[k] * resolution - texsize[k] * TEXTURE_STEP)
				/ 2;
		}
		texture = (float(*)[5]
		) malloc(texturesize[0] * texturesize[1] * sizeof(float[5]));
		hlassume(texture != nullptr, assume_NoMemory);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			texturemips[miplevel] = (byte(*)[4]) malloc(
				(texturesize[0] >> miplevel) * (texturesize[1] >> miplevel)
				* sizeof(byte[4])
			);
			hlassume(texturemips[miplevel] != nullptr, assume_NoMemory);
		}

		// calculate the texture

		for (t = 0; t < texturesize[1]; t++) {
			for (s = 0; s < texturesize[0]; s++) {
				float(*dest)[5] = &texture[t * texturesize[0] + s];
				VectorFill(*dest, 0);
				(*dest)[3] = 0;
				(*dest)[4] = 0;
			}
		}
		for (t = -side[1]; t < texsize[1] * TEXTURE_STEP + side[1]; t++) {
			for (s = -side[0]; s < texsize[0] * TEXTURE_STEP + side[0];
				 s++) {
				double s_vec, t_vec;
				double src_s, src_t;
				std::int32_t src_is, src_it;
				std::uint8_t src_index;
				std::uint8_t src_color[3];
				double dest_s, dest_t;
				std::int32_t dest_is, dest_it;
				float(*dest)[5];
				double light_s, light_t;
				float3_array light;

				s_vec = s + texmins[0] * TEXTURE_STEP + 0.5;
				t_vec = t + texmins[1] * TEXTURE_STEP + 0.5;

				if (resolution == 1) {
					dest_s = s_vec;
					dest_t = t_vec;
				} else // the final blurred texture is shifted by a half
					   // pixel so that lightmap samples align with the
					   // center of pixels
				{
					dest_s = s_vec / resolution + 0.5;
					dest_t = t_vec / resolution + 0.5;
				}
				dest_s = dest_s
					- texturesize[0] * floor(dest_s / texturesize[0]);
				dest_t = dest_t
					- texturesize[1] * floor(dest_t / texturesize[1]);
				dest_is = (std::int32_t) floor(dest_s
				); // dest_is = dest_s % texturesize[0]
				dest_it = (std::int32_t) floor(dest_t
				); // dest_it = dest_t % texturesize[1]
				dest_is
					= std::max(0, std::min(dest_is, texturesize[0] - 1));
				dest_it
					= std::max(0, std::min(dest_it, texturesize[1] - 1));
				dest = &texture[dest_it * texturesize[0] + dest_is];

				src_s = s_vec;
				src_t = t_vec;
				src_s = src_s - tex->width * floor(src_s / tex->width);
				src_t = src_t - tex->height * floor(src_t / tex->height);
				src_is = (std::int32_t) floor(src_s
				); // src_is = src_s % tex->width
				src_it = (std::int32_t) floor(src_t
				); // src_it = src_t % tex->height
				src_is = std::max(0, std::min(src_is, tex->width - 1));
				src_it = std::max(0, std::min(src_it, tex->height - 1));
				src_index = tex->canvas[src_it * tex->width + src_is];
				VectorCopy(tex->palette[src_index], src_color);

				// get light from the center of the destination pixel
				light_s = (s_vec + resolution * (dest_is + 0.5 - dest_s))
						/ TEXTURE_STEP
					- texmins[0];
				light_t = (t_vec + resolution * (dest_it + 0.5 - dest_t))
						/ TEXTURE_STEP
					- texmins[1];
				GetLight(f, texsize, light_s, light_t, light);

				(*dest)[4] += 1;
				if (!(texname.is_transparent_or_decal() && src_index == 255
					)) {
					for (k = 0; k < 3; k++) {
						float v = src_color[k]
							* pow(light[k] / denominator, gamma);
						(*dest)[k]
							+= 255 * std::max(0.0f, std::min(v, 255.0f));
					}
					(*dest)[3] += 255;
				}
			}
		}
		for (t = 0; t < texturesize[1]; t++) {
			for (s = 0; s < texturesize[0]; s++) {
				float(*src)[5] = &texture[t * texturesize[0] + s];
				byte(*dest)[4] = &texturemips[0][t * texturesize[0] + s];

				if ((*src)[4] == 0) // no samples (outside face range?)
				{
					VectorFill(*dest, 0);
					(*dest)[3] = 255;
				} else {
					if ((*src)[3] / (*src)[4] <= 0.4 * 255) // transparent
					{
						VectorFill(*dest, 0);
						(*dest)[3] = 0;
					} else // normal
					{
						for (j = 0; j < 3; j++) {
							int val
								= (int) floor((*src)[j] / (*src)[3] + 0.5);
							(*dest)[j] = std::max(0, std::min(val, 255));
						}
						(*dest)[3] = 255;
					}
				}
			}
		}

		for (miplevel = 1; miplevel < MIPLEVELS; miplevel++) {
			for (t = 0; t < (texturesize[1] >> miplevel); t++) {
				for (s = 0; s < (texturesize[0] >> miplevel); s++) {
					byte(*src[4])[4];
					byte(*dest)[4];
					double average[4];

					dest = &texturemips[miplevel]
									   [t * (texturesize[0] >> miplevel)
										+ s];
					src[0] = &texturemips[miplevel - 1]
										 [(2 * t)
											  * (texturesize[0]
												 >> (miplevel - 1))
										  + (2 * s)];
					src[1] = &texturemips[miplevel - 1]
										 [(2 * t)
											  * (texturesize[0]
												 >> (miplevel - 1))
										  + (2 * s + 1)];
					src[2] = &texturemips[miplevel - 1]
										 [(2 * t + 1)
											  * (texturesize[0]
												 >> (miplevel - 1))
										  + (2 * s)];
					src[3] = &texturemips[miplevel - 1]
										 [(2 * t + 1)
											  * (texturesize[0]
												 >> (miplevel - 1))
										  + (2 * s + 1)];

					VectorClear(average);
					average[3] = 0;
					for (k = 0; k < 4; k++) {
						for (j = 0; j < 3; j++) {
							average[j] += (*src[k])[3] * (*src[k])[j];
						}
						average[3] += (*src[k])[3];
					}

					if (average[3] / 4 <= 0.4 * 255) {
						VectorClear(*dest);
						(*dest)[3] = 0;
					} else {
						for (j = 0; j < 3; j++) {
							int val = (int
							) floor(average[j] / average[3] + 0.5);
							(*dest)[j] = std::max(0, std::min(val, 255));
						}
						(*dest)[3] = 255;
					}
				}
			}
		}

		// create its palette

		std::uint8_t palette[256][3];
		cq_searchnode_t* palettetree = CQ_AllocSearchTree(256);
		int paletteoffset;
		int palettenumcolors;

		{
			int palettemaxcolors;
			int numsamplepoints;
			unsigned char(*samplepoints)[3];

			if (texname.is_transparent_or_decal()) {
				paletteoffset = 0;
				palettemaxcolors = 255;
				VectorCopy(
					tex->palette[255], palette[255]
				); // the transparency color
			}
			/*else if (texname[0] == '!')
			{
				paletteoffset = 16; // because the 4th entry and the 5th
			entry are reserved for fog color and fog density for (j = 0; j <
			16; j++)
				{
					VectorCopy (tex->palette[j], palette[j]);
				}
				palettemaxcolors = 256 - 16;
			}*/
			else {
				paletteoffset = 0;
				palettemaxcolors = 256;
			}

			samplepoints = (unsigned char(*)[3]) malloc(
				texturesize[0] * texturesize[1] * sizeof(unsigned char[3])
			);
			hlassume(samplepoints != nullptr, assume_NoMemory);
			numsamplepoints = 0;
			for (t = 0; t < texturesize[1]; t++) {
				for (s = 0; s < texturesize[0]; s++) {
					byte(*src)[4] = &texturemips[0][t * texturesize[0] + s];
					if ((*src)[3] > 0) {
						VectorCopy(*src, samplepoints[numsamplepoints]);
						numsamplepoints++;
					}
				}
			}

			CQ_CreatePalette(
				numsamplepoints, samplepoints, palettemaxcolors,
				&palette[paletteoffset], palettenumcolors, palettetree
			);
			for (j = palettenumcolors; j < palettemaxcolors; j++) {
				VectorClear(palette[paletteoffset + j]);
			}

			free(samplepoints);
		}

		// emit a texinfo

		hlassume(g_numtexinfo < MAX_MAP_TEXINFO, assume_MAX_MAP_TEXINFO);
		f->texinfo = g_numtexinfo;
		texinfo_t* info = &g_texinfo[g_numtexinfo];
		g_numtexinfo++;

		*info = g_texinfo[originaltexinfonum];
		if (resolution != 1) {
			// apply a scale and a shift over the original vectors
			for (k = 0; k < 2; k++) {
				VectorScale(info->vecs[k], 1.0 / resolution, info->vecs[k]);
				info->vecs[k][3] = info->vecs[k][3] / resolution + 0.5;
			}
		}
		info->miptex = NewTextures_GetCurrentMiptexIndex();

		// emit a texture

		std::size_t miptexsize = sizeof(miptex_t);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			miptexsize += (texturesize[0] >> miplevel)
				* (texturesize[1] >> miplevel);
		}
		miptexsize += 2 + 256 * 3 + 2;
		miptex_t* miptex = (miptex_t*) malloc(miptexsize);
		hlassume(miptex != nullptr, assume_NoMemory);

		memset(miptex, 0, sizeof(miptex_t));
		miptex->width = texturesize[0];
		miptex->height = texturesize[1];
		byte* p = (byte*) miptex + sizeof(miptex_t);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			miptex->offsets[miplevel] = p - (byte*) miptex;
			for (int t = 0; t < (texturesize[1] >> miplevel); t++) {
				for (int s = 0; s < (texturesize[0] >> miplevel); s++) {
					byte(*src)[4]
						= &texturemips[miplevel]
									  [t * (texturesize[0] >> miplevel)
									   + s];
					if ((*src)[3] > 0) {
						if (palettenumcolors) {
							unsigned char point[3];
							VectorCopy(*src, point);
							*p = paletteoffset
								+ CQ_MapPoint(
									 point, &palette[paletteoffset],
									 palettenumcolors, palettetree
								);
						} else // this should never happen
						{
							*p = paletteoffset + 0;
						}
					} else {
						*p = 255;
					}
					p++;
				}
			}
		}
		*(short*) p = 256;
		p += 2;
		std::memcpy(p, palette, 256 * 3);
		p += 256 * 3;
		*(short*) p = 0;
		p += 2;
		if (p != (byte*) miptex + miptexsize) {
			Error("EmbedLightmapInTextures: internal error");
		}

		std::array<char8_t, wad_texture_name_max_length_with_last_null>
			embeddedLightmapName{};
		using namespace std::literals;
		if (texname.is_transparent_or_decal()) {
			std::ranges::copy(u8"{_rad"sv, embeddedLightmapName.data());
		} else if (texname.is_water()) {
			std::ranges::copy(u8"!_rad"sv, embeddedLightmapName.data());
		} else {
			std::ranges::copy(u8"__rad"sv, embeddedLightmapName.data());
		}
		if (originaltexinfonum < 0 || originaltexinfonum > 99999) {
			Error(
				"EmbedLightmapInTextures: internal error: texinfo out of range"
			);
		}
		static_assert(
			embedded_lightmap_texture_name_original_texinfo_index_starts_at
			== 5
		);
		embeddedLightmapName[5] = '0'
			+ (originaltexinfonum / 10000)
				% 10; // store the original texinfo
		embeddedLightmapName[6] = '0' + (originaltexinfonum / 1000) % 10;
		embeddedLightmapName[7] = '0' + (originaltexinfonum / 100) % 10;
		embeddedLightmapName[8] = '0' + (originaltexinfonum / 10) % 10;
		embeddedLightmapName[9] = '0' + (originaltexinfonum) % 10;
		static_assert(
			embedded_lightmap_texture_name_original_texinfo_index_length
			== 5
		);
		char table[36];
		for (int k = 0; k < 36; k++) {
			table[k] = k >= 10 ? 'a' + (k - 10)
							   : '0' + k; // same order as the ASCII table
		}
		unsigned int hash = Hash(miptexsize, miptex);
		embeddedLightmapName[10] = table[(hash / 36 / 36) % 26 + 10];
		embeddedLightmapName[11] = table[(hash / 36) % 36];
		embeddedLightmapName[12] = table[(hash) % 36];
		embeddedLightmapName[13] = table[(count / 36) % 36];
		embeddedLightmapName[14] = table[(count) % 36];
		embeddedLightmapName[15] = '\0';

		miptex->name = wad_texture_name{ embeddedLightmapName.begin() };

		NewTextures_PushTexture(miptexsize, miptex);
		count++;
		count_bytes += miptexsize;
		Developer(
			developer_level::message,
			"Created texture '%s' for face (texture %s) at (%4.3f %4.3f %4.3f)\n",
			miptex->name.c_str(), texname.c_str(), g_face_centroids[i][0],
			g_face_centroids[i][1], g_face_centroids[i][2]
		);

		free(miptex);

		CQ_FreeSearchTree(palettetree);

		free(texture);
		for (miplevel = 0; miplevel < MIPLEVELS; miplevel++) {
			free(texturemips[miplevel]);
		}
	}
	NewTextures_Write(); // update texdata now

	if (logged) {
		Log("added %d texinfos and textures (%d bytes)\n", count,
			count_bytes);
	}
}
